@startuml
skinparam classAttributeIconSize 0
class PointList{
start : MyPoint
end : MyPoint
pts : LinkedList<MyPoint>
+ PointList(start : MyPoint, end : MyPoint)
+ mergeTo(pl : PointList) : void
+ extendBack(p : MyPoint) : void
+ extendFront(p : MyPoint) : void
}
class AlgoImplicitPolyFunction{
- function : GeoFunctionNVar
- implicitPoly : GeoImplicit
+ AlgoImplicitPolyFunction(c : Construction, label : String, func : GeoFunctionNVar)
+ compute() : void
# setInputOutput() : void
+ getClassName() : Commands
+ getImplicitPoly() : GeoImplicit
}
AlgoImplicitPolyFunction --|> AlgoElement
class Rect{
evals : double[]
x : int
y : int
shares : int
status : int
fx : double
fy : double
singular : boolean
coords : Coords
+ Rect(x : int, y : int, fx : double, fy : double, singular : boolean)
+ split(geoImplicitCurve : GeoImplicitCurve, factor : int) : Rect[]
+ x1() : double
+ x2() : double
+ y1() : double
+ y2() : double
}
class Timer{
+ now : long
+ elapse : long
+ {static} newTimer() : Timer
+ reset() : void
+ record() : void
}
class AlgoIntersectImplicitpolys{
- p1 : GeoImplicit
- p2 : GeoImplicit
- c1 : GeoConic
- valPairs : List<double[]>
- {static} PolyX : int
- {static} PolyY : int
- univarType : int
- hints : List<GeoPoint>
+ AlgoIntersectImplicitpolys(c : Construction, p1 : GeoImplicit, c1 : GeoConic)
+ AlgoIntersectImplicitpolys(c : Construction, p1 : GeoImplicit, p2 : GeoImplicit)
# getYValue(t : double) : double
+ compute() : void
- computeY(a : GeoImplicit, b : GeoImplicit) : void
- {static} getNearRoots(roots : double[], solver : EquationSolverInterface, epsilon : double) : int
+ getClassName() : Commands
+ getRelatedModeID() : int
+ addSolutionHint(point : GeoPoint) : void
}
AlgoIntersectImplicitpolys --|> AlgoSimpleRootsPolynomial
class GeoImplicitCurve{
{static} MASK : int[]
- expression : FunctionNVar
- factorExpression : FunctionNVar[]
- diffExp : FunctionNVar[]
# locus : GeoLocus
# quadTree : QuadTree
- evalArray : double[]
- derEvalArray : double[]
- defined : boolean
- trace : boolean
- hasDerivatives : boolean
- isConstant : boolean
- degX : int
- degY : int
- coeff : double[][]
- coeffSquarefree : double[][][]
- eval : double[]
- calcPath : boolean
- updatePathNeeded : boolean
- expanded : Equation
- {static} fastDrawThreshold : long
- {static} XY_VARIABLES : String[]
- {static} SIMPLIFY_CONST : Traversing
+ GeoImplicitCurve(c : Construction)
+ GeoImplicitCurve(c : Construction, equation : Equation)
+ GeoImplicitCurve(c : Construction, func : FunctionNVar)
+ GeoImplicitCurve(curve : GeoImplicitCurve)
+ fromEquation(eqn : Equation, coeffEqn : double[][]) : void
- checkAbsValue(leftHandSide : ExpressionNode, rightHandSide : ExpressionNode) : boolean
- updateFromFactors(factors : ArrayList<ExpressionNode>) : void
- forgetFactors() : void
- updateCoeff(eqn : Equation) : void
- updateCoeffSquarefree(eqn : Equation, factor : int) : void
+ setCoeff(ev : ExpressionValue[][]) : void
+ setDerivatives(x : FunctionNVar, y : FunctionNVar, xy : FunctionNVar) : void
+ setExpanded(expanded : Equation) : void
- setCoeffSquarefree(ev : ExpressionValue[][], factor : int) : void
- resetCoeff() : void
- setDerivatives(x : FunctionVariable, y : FunctionVariable) : void
+ derivativeX(x : double, y : double) : double
+ derivativeY(x : double, y : double) : double
+ {static} evalDiffXPolyAt(x : double, y : double, coeff1 : double[][]) : double
+ {static} evalDiffYPolyAt(x : double, y : double, coeff1 : double[][]) : double
+ derivative(x : double, y : double) : double
- derivative(func : FunctionNVar, x : double, y : double) : double
+ getDerivativeX() : FunctionNVar
+ getDerivativeY() : FunctionNVar
+ getDerivativeXY() : FunctionNVar
+ hasDerivative() : boolean
+ getGeoClassType() : GeoClass
+ copy() : GeoElement
+ hasDrawable3D() : boolean
+ set(geo : GeoElementND) : void
+ isDefined() : boolean
+ setUndefined() : void
+ isGeoImplicitCurve() : boolean
+ toValueString(tpl : StringTemplate) : String
+ toString(tpl : StringTemplate) : String
# showInEuclidianView() : boolean
+ isEqualExtended(geo : GeoElementND) : ExtendedBoolean
+ evaluateImplicitCurve(x : double, y : double) : double
+ isLaTeXDrawableGeo() : boolean
+ evaluateImplicitCurve(x : double, y : double, factor : int) : double
+ getLocus() : GeoLocus
# getViewBounds() : double[]
+ updatePath() : void
- doUpdatePath() : void
- {static} get(ds : double[], i : int) : double
- updatePathQuadTree(x : double, y : double, w : double, h : double, scaleX : double, scaleY : double) : void
+ euclidianViewUpdate() : boolean
+ isPath() : boolean
+ isTraceable() : boolean
+ setTrace(trace : boolean) : void
+ getTrace() : boolean
# getExpressionXML(sb : StringBuilder) : void
- getXmlString() : String
# getXMLtags(sb : StringBuilder) : void
# getStyleXML(sb : StringBuilder) : void
+ setDefined() : void
+ pointChanged(PI : GeoPointND) : void
# locusPointChanged(PI : GeoPointND) : void
+ pathChanged(PI : GeoPointND) : void
# locusPathChanged(PI : GeoPointND) : void
+ isOnPath(PI : GeoPointND) : boolean
+ isOnPath(PI : GeoPointND, eps : double) : boolean
+ getMinParameter() : double
+ getMaxParameter() : double
+ isClosedPath() : boolean
+ createPathMover() : PathMover
+ translate(v : Coords) : void
- updateCoeffFromExpr() : void
+ translate(dx : double, dy : double) : void
+ mirror(Q : Coords) : void
- getFactor(factor : int) : FunctionNVar
+ mirror(g : GeoLineND) : void
+ dilate(r : NumberValue, S : Coords) : void
+ rotate(phi : NumberValue) : void
+ rotate(phi : NumberValue, S : GeoPointND) : void
+ mirror(c : GeoConic) : void
+ plugInRatPoly(pX : double[][], pY : double[][], qX : double[][], qY : double[][]) : void
+ {static} evalPolyCoeffAt(x : double, y : double, coeff : double[][]) : double
{static} polyMult(polyDest : double[][], polySrc : double[][], degDestX : int, degDestY : int, degSrcX : int, degSrcY : int) : void
+ getExpression() : FunctionNVar
+ {static} interpolate(fa : double, fb : double, p1 : double, p2 : double) : double
+ {static} interpolate(in : double[], out : double[]) : void
+ {static} probableInitialPoints(f1 : FunctionNVar, f2 : FunctionNVar, params : double[], n : int) : List<Coords>
+ {static} probableInitialPoints(f1 : FunctionNVar, f2 : FunctionNVar, xMin : double, yMin : double, xMax : double, yMax : double, n : int) : List<Coords>
+ hasLineOpacity() : boolean
+ getValueType() : ValueType
+ getCoeff() : double[][]
+ setCoeff(coeff : double[][]) : void
+ getDeg() : int
+ isOnScreen() : boolean
+ getDegX() : int
+ getDegY() : int
+ setToUser() : void
+ preventPathCreation() : void
+ isValidInputForm() : boolean
+ isInputForm() : boolean
+ setToImplicit() : void
+ throughPoints(points : GeoList) : void
+ throughPoints(points : ArrayList<GeoPointND>) : void
- setExpression() : void
- setFactorExpression() : void
- setCoeff(coeffMatrix : double[][][], updatePath : boolean) : void
- setCoeff(coeffMatrix : double[][], updatePath : boolean) : void
- doSetCoeff(coeffMatrix : double[][]) : void
+ getTransformedCoordSys() : CoordSys
# toRawValueString(tpl0 : StringTemplate) : String
# getVariableNames() : String[]
- {static} addPow(sb : StringBuilder, exp : int, tpl : StringTemplate) : void
- {static} appendMultiply(sb : StringBuilder) : void
+ evaluate(x : double, y : double, factor : int) : double
+ evaluate(val : double[], factor : int) : double
+ evaluate(x : double, y : double) : double
+ evaluate(val : double[]) : double
+ getEquation() : Equation
+ setCoeff(coeff : double[][][]) : void
+ getLabelDelimiter() : char
+ getFunctionDefinition() : FunctionNVar
+ getPlaneEquation() : Coords
+ getTranslateZ() : double
factorLength() : int
+ getEquationVariables() : String[]
+ getDescriptionMode() : DescriptionMode
+ setTypeFromXML(style : String, parameter : String, force : boolean) : boolean
+ replaceChildrenByValues(var : GeoElement) : void
+ {static} setFastDrawThreshold(threshold : int) : void
+ doRemove() : void
+ setViewFlags(viewSet : List<Integer>) : void
+ isValidType() : boolean
}
GeoImplicitCurve ..|> EuclidianViewCE
GeoImplicitCurve ..|> Traceable
GeoImplicitCurve ..|> Translateable
GeoImplicitCurve ..|> Dilateable
GeoImplicitCurve ..|> Mirrorable
GeoImplicitCurve ..|> ConicMirrorable
GeoImplicitCurve ..|> Transformable
GeoImplicitCurve ..|> Rotatable
GeoImplicitCurve ..|> GeoImplicit
GeoImplicitCurve ..|> ReplaceChildrenByValues
GeoImplicitCurve --|> GeoElement
class AlgoImplicitPolyTangentLine{
- poly : GeoImplicit
- line : GeoLineND
- tangentPoly : GeoImplicit
+ AlgoImplicitPolyTangentLine(c : Construction, poly : GeoImplicit, line : GeoLineND)
+ compute() : void
# setInputOutput() : void
+ getClassName() : Commands
+ getTangentCurve() : GeoImplicit
+ getVec() : GeoElement
+ vecDefined() : boolean
+ getTangents(ip : GeoPoint[], tangents : OutputHandler<GeoLine>) : void
+ getTangentPoint(geo : GeoElement, l : GeoLine) : GeoPointND
}
AlgoImplicitPolyTangentLine ..|> AlgoTangentHelper
AlgoImplicitPolyTangentLine --|> AlgoElement
class AlgoImplicitPolyTangentCurve{
- poly : GeoImplicit
- point : GeoPointND
- tangentPoly : GeoImplicit
- pointOnPath : boolean
+ AlgoImplicitPolyTangentCurve(c : Construction, poly : GeoImplicit, point : GeoPointND, pointOnPath : boolean)
+ compute() : void
# setInputOutput() : void
+ getClassName() : Commands
+ getTangentCurve() : GeoImplicit
+ getVec() : GeoElement
+ vecDefined() : boolean
+ getTangents(ip : GeoPoint[], tangents : OutputHandler<GeoLine>) : void
+ getTangentPoint(geo : GeoElement, line : GeoLine) : GeoPointND
}
AlgoImplicitPolyTangentCurve ..|> AlgoTangentHelper
AlgoImplicitPolyTangentCurve --|> AlgoElement
class AlgoIntersectImplicitpolyParametric{
- tx : PolynomialFunction
- ty : PolynomialFunction
- p : GeoImplicit
- l : GeoLine
- f : GeoFunctionable
- tangentPoints : GeoPoint[]
+ AlgoIntersectImplicitpolyParametric(c : Construction, p : GeoImplicit, l : GeoLine)
+ AlgoIntersectImplicitpolyParametric(c : Construction, p : GeoImplicit, f : GeoFunctionable)
# getYValue(t : double) : double
# getXValue(t : double) : double
+ compute() : void
- computeNonPoly(fun : GeoFunction, transpose : boolean) : void
- mergeWithTangentPoints() : void
+ getClassName() : Commands
+ getRelatedModeID() : int
}
AlgoIntersectImplicitpolyParametric --|> AlgoSimpleRootsPolynomial
class WebExperimentalQuadTree{
- {static} RES_COARSE : int
- {static} MAX_SPLIT : int
- plotDepth : int
- segmentCheckDepth : int
- sw : int
- sh : int
- grid : Rect[][]
- timer : Timer
+ WebExperimentalQuadTree()
+ updatePath() : void
+ createTree(r : Rect, depth : int, factor : int) : void
+ plot(r : Rect, depth : int, factor : int) : void
- nonempty(ry : int, rx : int) : void
+ polishPointOnPath(pt : GeoPointND) : void
- onScreen(v : double, mn : double, mx : double) : double
}
WebExperimentalQuadTree --|> QuadTree
class AlgoImplicitPolyThroughPoints{
- P : GeoList
- implicitPoly : GeoImplicit
+ AlgoImplicitPolyThroughPoints(cons : Construction, label : String, p : GeoList)
+ getImplicitPoly() : GeoImplicit
+ getP() : GeoList
# setInputOutput() : void
+ compute() : void
+ getClassName() : Commands
}
AlgoImplicitPolyThroughPoints --|> AlgoElement
class PolynomialUtils{
+ {static} polynomialDivision(cp : double[], cd : double[]) : double[]
+ {static} polynomialDivision(p : PolynomialFunction, d : PolynomialFunction) : PolynomialFunction
+ {static} getDegree(p : PolynomialFunction) : int
+ {static} getDegree(c : double[]) : int
+ {static} getLeadingCoeff(c : double[]) : double
+ {static} getLeadingCoeff(p : PolynomialFunction) : double
+ {static} eval(c : double[], x : double) : double
+ {static} coeffMinDeg(coeff : double[][]) : double[][]
+ {static} rootPolishing(pair : double[], p1 : GeoImplicit, line : double[]) : boolean
+ {static} rootPolishing(pair : double[], p1 : GeoImplicit, p2 : GeoImplicit) : boolean
- {static} rootPolishing(pair : double[], p1 : GeoImplicit, p2 : GeoImplicit, line : double[]) : boolean
+ {static} checkNumericCoeff(coeff : ExpressionValue[][], simplify : boolean) : boolean
}
class AlgoTangentImplicitpoly{
- p : GeoImplicit
- ip : GeoPoint[]
- tangents : OutputHandler<GeoLine>
- algoIntersect : AlgoIntersect
- labels : String[]
- algoTangentPoly : AlgoTangentHelper
# AlgoTangentImplicitpoly(c : Construction, labels : String[], p : GeoImplicit)
+ AlgoTangentImplicitpoly(c : Construction, labels : String[], p : GeoImplicit, R : GeoPointND)
+ AlgoTangentImplicitpoly(c : Construction, labels : String[], p : GeoImplicit, g : GeoLineND)
# setInputOutput() : void
+ compute() : void
+ getClassName() : Commands
+ getRelatedModeID() : int
+ getTangents() : GeoLine[]
+ setLabels(labels : String[]) : void
+ getTangentPoints() : GeoPoint[]
+ getTangentPoint(geo : GeoElement, line : GeoLine) : GeoPointND
}
AlgoTangentImplicitpoly ..|> TangentAlgo
AlgoTangentImplicitpoly --|> AlgoElement
class QuadTree{
- geoImplicitCurve : GeoImplicitCurve
+ {static} T0000 : int
+ {static} T0001 : int
+ {static} T0010 : int
+ {static} T0011 : int
+ {static} T0100 : int
+ {static} T0101 : int
+ {static} T0110 : int
+ {static} T0111 : int
+ {static} T_INV : int
+ {static} EMPTY : int
+ {static} VALID : int
+ LIST_THRESHOLD : int
# x : double
# y : double
# w : double
# h : double
# scaleX : double
# scaleY : double
# locusPoints : ArrayList<MyPoint>
- openList : LinkedList<PointList>
- pts : MyPoint[]
- p1 : PointList
- p2 : PointList
- temp : MyPoint
- itr1 : ListIterator<PointList>
- itr2 : ListIterator<PointList>
+ QuadTree(geoImplicitCurve : GeoImplicitCurve)
+ config(r : Rect) : int
+ sign(val : double) : int
+ abortList() : void
- {static} equal(q1 : MyPoint, q2 : MyPoint) : boolean
+ addSegment(r : Rect, factor : int) : int
+ createSegment(r : Rect, factor : int) : int
- {static} minAbs(a : double, b : double) : double
+ updatePath(startX : double, startY : double, width : double, height : double, slX : double, slY : double, locus : GeoLocus) : void
+ polishPointOnPath(pt : GeoPointND) : void
+ edgeConfig(r : Rect) : int
- {static} intersect(c1 : double, c2 : double) : int
+ {abstract} updatePath() : void
}
class AlgoAsymptoteImplicitPoly{
- ip : GeoImplicit
- g : GeoList
- solver : EquationSolverInterface
+ AlgoAsymptoteImplicitPoly(c : Construction, label : String, ip : GeoImplicit)
+ getClassName() : Commands
# setInputOutput() : void
+ getResult() : GeoList
- makeLines(p : ArrayList<Double>, a : double, b : double) : void
+ compute() : void
}
AlgoAsymptoteImplicitPoly --|> AlgoElement
class AlgoIntersectImplicitpolyPolyLine{
# implicitPolynomial : GeoImplicit
# poly : GeoPoly
# outputPoints : OutputHandler<GeoPoint>
# hasLabels : boolean
# polyclosed : boolean
# numOfOutputPoints : int
# polyPointCount : int
# segCountOfPoly : int
# intersectCoords : ArrayList<Coords>
- tempSegEndPoints : GeoPoint[]
- tempSeg : GeoSegment
- tx : PolynomialFunction
- ty : PolynomialFunction
- eqnSolver : EquationSolverInterface
+ AlgoIntersectImplicitpolyPolyLine(cons : Construction, labels : String[], implicitPolynomial : GeoImplicit, poly : GeoPoly, polyClosed : boolean)
+ AlgoIntersectImplicitpolyPolyLine(cons : Construction, implicitPolynomial : GeoImplicit, poly : GeoPoly, polyClosed : boolean)
+ getIntersectionPoints() : GeoPoint[]
# getLastDefinedIntersectionPoints() : GeoPoint[]
# setInputOutput() : void
+ compute() : void
+ getClassName() : GetCommand
+ getRelatedModeID() : int
- computePolyLineIntersection(tempSeg2 : GeoSegment, intersectCoords2 : ArrayList<Coords>) : void
+ {static} lineIntersect(coeff : double[][], tx : PolynomialFunction, ty : PolynomialFunction) : PolynomialFunction
- setRootsPolynomialWithinRange(intersectCoords2 : ArrayList<Coords>, rootsPoly : PolynomialFunction, min : double, max : double) : void
- {static} distancePairSq(p1 : Coords, p2 : Coords) : double
- initElements() : void
+ setLabels(labels : String[]) : void
# createOutputPoints() : OutputHandler<GeoPoint>
+ getImplicitPolynomial() : GeoImplicit
+ getPoly() : GeoPoly
+ isPolyclosed() : boolean
}
AlgoIntersectImplicitpolyPolyLine --|> AlgoIntersect
class AlgoDependentImplicitPoly{
- coeff : ExpressionValue[][]
- geoElement : GeoElementND
- dependentFromFunctions : Set<FunctionNVar>
- equation : Equation
- equationExpanded : Equation
+ AlgoDependentImplicitPoly(c : Construction, equ : Equation, definition : ExpressionNode, simplify : boolean)
+ AlgoDependentImplicitPoly(c : Construction, equ : Equation, definition : ExpressionNode, simplify : boolean, evaluatedDef : ExpressionValue)
- expandEquation() : void
+ compute() : void
# replaceGeoElement(newElem : GeoElementND) : void
+ getEquation() : Equation
- compute(first : boolean) : void
- setLine() : void
- setConic() : void
# addAllFunctionalDescendents(algo : AlgoElement, set : Set<FunctionNVar>, algos : Set<AlgoElement>) : void
# setInputOutput() : void
+ getClassName() : Algos
+ getGeo() : GeoElement
+ toString(tpl : StringTemplate) : String
# toExpString(tpl : StringTemplate) : String
+ {static} equationWithLabel(geo : GeoElementND, tpl : StringTemplate) : String
}
AlgoDependentImplicitPoly --|> AlgoElement
class ImplicitIntersectionFinder{
+ {static} SAMPLE_SIZE_2D : int
+ {static} OUTPUT_SIZE : int
- {static} EPS : double
- {static} ROOT_ACCURACY : double
- {static} ACCURACY : double
- {static} DECAY_RATE : double
- {static} MOMENT_RATE : double
- {static} MIN_LAMBDA : double
- ImplicitIntersectionFinder()
+ {static} findIntersections(fun1 : FunctionNVar, fun2 : FunctionNVar, xMin : double, yMin : double, xMax : double, yMax : double, samples : int, outputs : int, vals : List<double[]>) : void
{static} intersections(f : FunctionNVar[], params : double[], guess : List<Coords>, outputs : int, vals : List<double[]>) : void
{static} insert(pair : double[], pairs : List<double[]>) : void
+ {static} intersects(fn1 : FunctionNVar, fn2 : FunctionNVar, params : double[], guess : List<Coords>, outputs : int, vals : List<double[]>) : void
- {static} finiteDiffX(func : FunctionNVar, x : double, y : double) : double
- {static} finiteDiffY(func : FunctionNVar, x : double, y : double) : double
}
AlgoImplicitPolyFunction--"- implicitPoly" GeoImplicit
AlgoIntersectImplicitpolys--"- p1" GeoImplicit
AlgoIntersectImplicitpolys--"- p2" GeoImplicit
GeoImplicitCurve--"# quadTree" QuadTree
AlgoImplicitPolyTangentLine--"- poly" GeoImplicit
AlgoImplicitPolyTangentLine--"- tangentPoly" GeoImplicit
AlgoImplicitPolyTangentCurve--"- poly" GeoImplicit
AlgoImplicitPolyTangentCurve--"- tangentPoly" GeoImplicit
AlgoIntersectImplicitpolyParametric--"- p" GeoImplicit
WebExperimentalQuadTree--"- timer" Timer
AlgoImplicitPolyThroughPoints--"- implicitPoly" GeoImplicit
AlgoTangentImplicitpoly--"- p" GeoImplicit
AlgoTangentImplicitpoly--"- algoTangentPoly" AlgoTangentHelper
QuadTree--"- geoImplicitCurve" GeoImplicitCurve
QuadTree--"- p1" PointList
QuadTree--"- p2" PointList
AlgoAsymptoteImplicitPoly--"- ip" GeoImplicit
AlgoIntersectImplicitpolyPolyLine--"# implicitPolynomial" GeoImplicit
interface GeoImplicit{
getCoeff() : double[][]
setCoeff(coeff : double[][]) : void
setCoeff(coeff : double[][][]) : void
setDefined() : void
getDeg() : int
isOnScreen() : boolean
getLocus() : GeoLocusND<? extends MyPoint>
getDegX() : int
getDegY() : int
translate(dx : double, dy : double) : void
getExpression() : FunctionNVar
isValidInputForm() : boolean
isInputForm() : boolean
fromEquation(equation : Equation, coeff : double[][]) : void
preventPathCreation() : void
setCoeff(coeff : ExpressionValue[][]) : void
throughPoints(points : GeoList) : void
derivativeX(x : double, y : double) : double
derivativeY(x : double, y : double) : double
evaluateImplicitCurve(x : double, y : double) : double
getTransformedCoordSys() : CoordSys
getFunctionDefinition() : FunctionNVar
getPlaneEquation() : Coords
getTranslateZ() : double
setDerivatives(x : FunctionNVar, y : FunctionNVar, xy : FunctionNVar) : void
setExpanded(equationExpanded : Equation) : void
}
GeoImplicit --|> Path
GeoImplicit --|> EquationValue
interface AlgoTangentHelper{
getTangentCurve() : GeoImplicit
getVec() : GeoElement
vecDefined() : boolean
getTangents(ip : GeoPoint[], tangents : OutputHandler<GeoLine>) : void
getTangentPoint(geo : GeoElement, line : GeoLine) : GeoPointND
}
@enduml